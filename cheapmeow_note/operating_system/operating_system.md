- [进程调度](#进程调度)
  - [进程和线程有何不同？线程同步有哪些方式？一个线程有几个栈？有没有无锁线程同步方式？](#进程和线程有何不同线程同步有哪些方式一个线程有几个栈有没有无锁线程同步方式)
  - [调度算法](#调度算法)
    - [性能最佳的调度算法 最短作业优先算法 SJF](#性能最佳的调度算法-最短作业优先算法-sjf)
- [内存管理](#内存管理)
- [Shell](#shell)
  - [基础](#基础)
  - [查找已删除文件](#查找已删除文件)

## 进程调度

### 进程和线程有何不同？线程同步有哪些方式？一个线程有几个栈？有没有无锁线程同步方式？

进程是资源分配的最小单位，线程是处理机调度的最小单位

线程有独立的调用栈

---

线程同步：互斥锁、读写锁、条件变量、信号量

互斥锁可以锁定一个代码块，对于被锁定的这个代码块，所有的线程只能串行处理，不能并行处理。

读写锁是互斥锁的升级版，所有线程的读操作都是并行的，只有写操作是串行的。程序中的读操作越多，读写锁性能就越高，相反，若程序中全是写操作，那么读写锁会退化成互斥锁。

条件变量的主要作用不是处理线程同步，而是进行线程的阻塞。常常和互斥锁一起用在生产者和消费者模型中。举个例子：当任务队列为空时，消费者无法消费，使用条件变量把消费者线程阻塞住，等待生产者生产出任务后，再唤醒一个或多个被条件变量阻塞的消费者线程；反过来也可以控制生产者生产的上限，当任务队列达到一个上限值时用条件变量阻塞住生产者线程，直到消费者把任务消费后再唤醒被条件变量阻塞的生产者线程。

信号量可以实现线程同步也可以实现进程同步，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量主要阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要和互斥锁一起使用。信号量也可以用来实现生产者消费者模型，在用条件变量实现生产者消费者模型时需要自己做条件判断，而使用信号量就不需要。举个例子：初始化生产者的信号量为5，消费者的信号量为0，因为消费者信号量为0所以会被阻塞，生产者进行一次生产后会将自己的信号量减1，将消费者信号量加1，这时消费者解除阻塞，进行消费后再将自己的信号量减1生产者信号量加1。

> 线程同步和线程安全不一样
>
> 同步指的是任务目的上的同步，比如消费者生产者问题，生产者的数量可以同时被多个消费者访问，不一定线程安全

自旋锁与互斥锁类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用于一下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多成本。

屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出，但屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有线程达到屏障后可以接着工作。

---

无锁线程同步方式：CAS

CAS机制的工作原理可以简单描述为三个步骤：比较（Compare）、交换（Swap）和设置（Set）。

比较（Compare）：首先，线程会获取内存中某个变量的当前值（V）与预期原值（A）进行比较。这一步是为了确保在数据被其他线程修改之前，当前线程能够获取到最新的数据。

交换（Swap）：如果当前值等于预期原值，说明数据没有被其他线程修改过，此时线程会将该变量更新为新的值（B）。如果当前值不等于预期原值，说明数据已经被其他线程修改过，此时线程会放弃更新，并重新尝试比较和交换操作。

设置（Set）：只有在比较成功后，才会将新值写入到内存中。这一过程是原子性的，不会被其他线程中断。因此，CAS机制可以保证数据的一致性。

二、CAS的应用场景

CAS机制适用于争用不严重且等待时间相对较短的情况。在高并发环境下，CAS机制可以降低线程的活跃度，减小对CPU资源的竞争压力。常见的应用场景包括：

无锁数据结构：如无锁队列、无锁栈等，这些数据结构通过使用CAS机制实现线程安全，避免了传统锁机制带来的性能开销。

数据库事务：在数据库事务处理中，CAS机制可以保证事务的原子性和一致性。当多个事务同时对同一数据进行修改时，CAS机制可以确保只有一个事务能够成功修改数据。

并发算法：如并发哈希表、并发树等，这些算法通过使用CAS机制实现线程安全，提高了算法的并发性能。

三、实践建议

合理选择CAS机制：虽然CAS机制具有很多优点，但它并不适用于所有场景。在选择CAS机制时，需要充分考虑数据的争用情况和等待时间。如果争用严重或等待时间较长，可能需要考虑其他同步机制。

避免ABA问题：在使用CAS机制时，可能会出现ABA问题。这是因为CAS机制只比较变量的值是否相等，而不关心变量的值在比较和交换之间是否发生过变化。为了避免ABA问题，可以使用版本号或时间戳等机制来辅助判断。

自旋与重试：当CAS操作失败时，线程通常会进行自旋和重试。为了避免过度自旋导致性能下降，可以设置最大重试次数或超时时间等限制条件。

无锁化栈、队列

[https://blog.csdn.net/qq_43593404/article/details/130598220](https://blog.csdn.net/qq_43593404/article/details/130598220)

[https://blog.csdn.net/weixin_43376501/article/details/108325765](https://blog.csdn.net/weixin_43376501/article/details/108325765)

看来我读书还是读少了

[高并发情况下怎样尽量实现无锁编程](http://www.blogjava.net/paulwong/archive/2015/07/13/426201.html)

### 调度算法

#### 性能最佳的调度算法 最短作业优先算法 SJF

题目:

若被调度进程集合恒定,考察指标为平均周转时间,试证明 SJF 策略生成的调度方案理论最优

证明:

假设被调度进程集合有 n 个元素.对这 n 个进程的任意排列 $\{P_0,P_1,P_2,...,P_{n-1}\}$,便是一种调度方案.

设 $T_1$ 为任意进程调度方案产生的平均周转时间

$$T_1=[M_0+(M_0+M_1)+...+(M_0+M_1+...+M_{n-1})]/n;$$

其中 $M_i$ 是第 $i+1$ 个执行的进程的运行时间

对 $M_0,M_1,...,M_{n-1}$ 递增排序,得 $M_{k_0} ， M_{k_1}， …… ，M_{k_{n-1}}$

设 $T_2$ 为 SJF 策略生成的调度方案的平均周转时间,则:

$$T_2 = [ M_{k_0} + (M_{k_0} + M_{k_1})+……+( M_{k_0} + M_{k_1} + ……+ M_{k_{n-1}})]/n$$

对比构成 $T_1$ 和 $T_2$ 的每个累加项,后者永远不大于前者, $T_2$ 是 $T_1$ 中最小值.故,能够产生 $T_2$ 的调度方案必为理论最优,而 $T_2$ 调度方案是 SJF 生成的,得证.

## 内存管理

题：操作系统采用分页式存储管理(PAGING)方法，要求( )

A. 每个进程拥有一张页表，且进程的页表驻留在内存中

B. 每个进程拥有一张页表，但只要执行进程的页表驻留在内存中，其他进程的页表不必驻留在内存中

C. 所有进程共享一张页表，以节约有限的内存空间，但页表必须驻留在内存中

D. 所有进程共享一张页表，只有页表中当前使用的页面必须驻留在内存中，以最大限度地节约有限的内存空间

答案：B

感觉……似乎没有为什么，就是这样设计的？我查不到解释

## Shell

### 基础

$? 表示上一个命令的执行状态

三元表达式 `[条件表达式] && 条件为真则执行的语句 || 条件为假则执行的语句`

### 查找已删除文件

题：有时候因为磁盘空间快满了，我们需要删除一些log文件，但是忘记停止程序了，日志删除后，发现磁盘空间并没有释放，这时候我们通常使用以下哪种方式查找已删除文件的进程占用

A. ps

B. lsof

C. top

D. df

在Linux中，当我们使用rm在linux上删除了大文件，但是如果有进程打开了这个大文件，却没有关闭这个文件的句柄，那么linux内核还是不会释放这个文件的磁盘空间，最后造成磁盘空间占用100%，整个系统无法正常运行。这种情况下，通过df和du命令查找的磁盘空间，两者是无法匹配的，可能df显示磁盘100%，而du查找目录的磁盘容量占用却很小。

遇到这种情况，基本可以断定是某些大文件被某些程序占用了，并且这些大文件已经被删除了，但是对应的文件句柄没有被某些程序关闭，造成内核无法收回这些文件占用的空间