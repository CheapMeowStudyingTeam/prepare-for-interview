#### FXAA 1.0

[FXAA算法演义](https://zhuanlan.zhihu.com/p/373379681)

1. 边缘判定算法

2. 边缘像素的混合因子计算

##### 边缘判定算法

1. 读取上下左右4个方向 + 自身的像素亮度

2. 筛选出其中的最大值lumaMax和最小值lumaMin

3. 令对比度lumaContrast = lumaMax - lumaMin

4. 当对比度超过一定阈值时，便认为当前像素为边缘像素

只要是对比度高的像素，它都视作边缘像素进行处理

这可能会使图像丢失一些局部高频信息，使得画面不够锐利。

为了缓解这个问题，FXAA1.0在阈值判断这里额外加入一个修正参数

用中文来表示就是

最终阈值 = max(绝对阈值, lumaMax * 相对阈值比例)

这就使得明亮的地方需要更高的周边对比度才能被判定为边缘

##### 边缘像素的混合因子计算

1. 上下左右4个方向，到底与哪个方向混合?

2. 混合的比例是多少?

###### 边缘横纵判定

1. 在横边上

2. 在纵边上

3. 在角上

哪个方向的梯度大，边的走向就是哪边

###### 边缘法线计算

哪个方向的梯度大，法线就朝哪边

###### 混合因子计算

1. 需要在"高对比度的像素之间"构造出渐变

2. 不破坏像素之间正常的渐变关系

首先对NSEW4个方向的像素亮度求平均，计算出中间像素的期望亮度

```
half lumaL = (lumaN + lumaS + lumaE + lumaW) * 0.25;
```

然后考察中间像素的实际亮度与期望亮度之差

```
half lumaDeltaML = abs(lumaM - lumaL);
```

这个差值如果是0，说明当前的中间像素亮度已经完美符合，不用任何修改。否则，令

```
float blend = lumaDeltaML / lumaContrast;
```

lumaContrast在前面已经说过，是N、S、W、E、M，5个像素中最大亮度-最小亮度。易知，blend范围位于0~1。

最终颜色采样代码如下:

```
half4 finalColor = SampleLinear(tex,pixelCoord + normal * blendL);
```

即

中间像素亮度(lumaM)与期望亮度(lumaL)的差值越大，混合因子(blend)越趋向1，也即中间像素的颜色越往其亮度的最大梯度方向(normal)偏移

###### 成对模糊

像素 A 在一个边缘上，被模糊

那么紧挨着这个边缘上的像素 A 的像素 B 也会被判定为边缘

所以模糊是成对出现的

###### FXAA 的使用规范

1. 最好在完成所有后处理效果之后再执行FXAA

2. 最好在sRGB空间执行

3. 需要在LDR空间执行

这些规范不难理解。因为FXAA图像抗锯齿是基于"视觉的"而不是基于物理的。因此在我们进行亮度计算时，必须时基于"视觉"的亮度，而不是"物理"的亮度。另一方面，HDR到LDR的ToneMap不是线性的，所以即便在HDR空间中执行FXAA，ToneMap后也会失效。

#### FXAA 3.11

更改了混合因子计算的方式

现在使用一个边缘搜索算法

1. 首先确定边缘像素的横纵向

2. 往边缘两侧按照给定的步长进行边缘终点搜索

3. 确定了边缘线段的两个端点后，可以计算出当前像素在线段中的位置

4. 根据像素在线段中所处的位置来计算出混合因子

于是以上算法归纳出两个待解决的问题:

1. 如何判定搜索的目标像素为边缘终点?

2. 边缘上每个点的位置与混合因子满足怎样的关系？

##### 边缘终点判定

将搜索的起始点定为像素往normal方向偏移0.5个单位的位置

使用线性插值采样，那么采样结果将是边缘两侧像素的平均亮度。

将起始点亮度记为lumaStart

往两侧一个个像素进行判定，直到发现亮度与lumaStart的差值超过一定阈值，便认为到头了

##### 混合因子计算

多种形态

设边缘线长为edgeLength(可以通过搜索到的两个端点位置相减得到)

计算出距离当前像素比较近的一个端点，记为targetP，距离记为dst

考察targetP与当前像素是否属于同一阵营

如果是,则blend为0，即当前像素保持原样，不进行混合

如果否,则blend = abs(0.5 - dst/edgeLength)

> 同一阵营这个，还真不懂在说什么

##### 搜索步长优化

给定一个最大搜索次数

##### 额外对角线采样

之前确认方向的时候，只看四个梯度还不够，还要四个对象线的亮度梯度
